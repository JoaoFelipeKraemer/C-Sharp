Aplicando Inje√ß√£o de Depend√™ncias no ASP.NET

Para garantir que todas as depend√™ncias sejam injetadas corretamente, o ASP.NET disp√µe de uma solu√ß√£o nativa,
 sem a necessidade de instalar novos pacotes ao projeto.
 Ele fornece um container de servi√ßos, IServiceProvider, no qual s√£o registrados todos os servi√ßos necess√°rios.

üëÄ: Este container pode ser adicionado nos arquivos Program.cs, Startup.cs ou em uma classe de extens√£o do IServiceProvider


Esses servi√ßos podem ser injetados com tr√™s tipos de ciclo de vida:

1 Transient: cria-se uma inst√¢ncia nova para cada vez que o servi√ßo √© requisitado;
2 Scoped: cria-se uma inst√¢ncia nova para cada escopo diferente;
3 Singleton: cria-se apenas uma inst√¢ncia para toda a aplica√ß√£o.
=====================================================
EXEMPLO

Vamos imaginar que estamos desenvolvendo uma API para uma concession√°ria de carros e tenhamos o endpoint 

v1/car-models 

que ir√° retornar uma lista de modelos de carros:

public class CarModelController : Controller
{
    private readonly ICarModelRepository _repository;

    public CarModelController(ICarModelRepository repository)
    {
        _repository = repository;
    }

    [Route("v1/car-models")]
    [HttpGet]
    public IEnumerable<CarModel> Get()
    {
        return _repository.Get();
    }
}

Onde o reposit√≥rio, injetado via interface, e sua interface s√£o descritos da seguinte forma:

public interface ICarModelRepository
{
    IEnumerable<CarModel> Get();
}

public class CarModelRepository : ICarModelRepository
{
    public IEnumerable<CarModel> Get()
    {
        // Detalhes de implementa√ß√£o para pegar os modelos de carro no banco de dados
    }
}

Para utilizar a inje√ß√£o de depend√™ncias do ASP.NET, precisamos configurar os Scoped Services:


// Startup.cs
public void ConfigureServices(IServiceCollection services)
{
    services.AddMvc();
    services.AddScoped<ICarModelRepository, CarModelRepository>();
}

Conclus√£o
A Inje√ß√£o de Depend√™ncias √© um padr√£o de projeto muito utilizado no mercado por facilitar a manuten√ß√£o e a evolu√ß√£o dos projetos.
Como vimos no exemplo, conseguimos reutilizar uma classe para realizar fun√ß√µes diferentes.
 Ter essa flexibilidade reduz o tempo de desenvolvimento, pois n√£o precisamos ficar criando classes diferentes
  que t√™m seus detalhes de implementa√ß√£o muito parecidos.